/* Copyright (C) 2019 Open Information Security Foundation
*
* You can copy, redistribute or modify this Program under the terms of
* the GNU General Public License version 2 as published by the Free
* Software Foundation.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* version 2 along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
* 02110-1301, USA.
*/

#ifndef __RUST_BINDINGS_GEN_H_
#define __RUST_BINDINGS_GEN_H_

/* Generated with cbindgen:0.14.0 */

/* DO NOT EDIT This file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "rust.h"

enum HTTP2TransactionState {
    HTTP2StateIdle = 0,
    HTTP2StateOpen = 1,
    HTTP2StateReserved = 2,
    HTTP2StateDataClient = 3,
    HTTP2StateHalfClosedClient = 4,
    HTTP2StateDataServer = 5,
    HTTP2StateHalfClosedServer = 6,
    HTTP2StateClosed = 7,
    HTTP2StateGlobal = 8,
};
typedef uint8_t HTTP2TransactionState;

enum MQTTFlagState {
    MQTT_DONT_CARE = 0,
    MQTT_MUST_BE_SET = 1,
    MQTT_CANT_BE_SET = 2,
};
typedef uint8_t MQTTFlagState;

enum SSHConnectionState {
    SshStateInProgress = 0,
    SshStateBannerWaitEol = 1,
    SshStateBannerDone = 2,
    SshStateFinished = 3,
};
typedef uint8_t SSHConnectionState;

/**
 * Container for parsed Asn1 objects
 */
typedef struct Asn1 Asn1;

typedef struct DCEIfaceData DCEIfaceData;

typedef struct DCEOpnumData DCEOpnumData;

typedef struct DCERPCState DCERPCState;

typedef struct DCERPCTransaction DCERPCTransaction;

typedef struct DCERPCUDPState DCERPCUDPState;

typedef struct RSDNSTransaction RSDNSTransaction;

/**
 * Struct to hold parsed asn1 keyword options
 */
typedef struct DetectAsn1Data DetectAsn1Data;

typedef struct DetectDnsOpcode DetectDnsOpcode;

typedef struct HTTP2State HTTP2State;

typedef struct HTTP2Transaction HTTP2Transaction;

typedef struct JsonBuilder JsonBuilder;

typedef struct MQTTState MQTTState;

typedef struct MQTTTransaction MQTTTransaction;

typedef struct NFSState NFSState;

typedef struct NFSTransaction NFSTransaction;

typedef struct RFBState RFBState;

typedef struct RFBTransaction RFBTransaction;

typedef struct RdpState RdpState;

typedef struct RdpTransaction RdpTransaction;

typedef struct SIPState SIPState;

typedef struct SIPTransaction SIPTransaction;

typedef struct SMBState SMBState;

typedef struct SMBTransaction SMBTransaction;

typedef struct X509 X509;

/**
 * A "mark" or saved state for a JsonBuilder object.
 *
 * The name is full, and the types are u64 as this object is used
 * directly in C as well.
 */
typedef struct {
    uint64_t position;
    uint64_t state_index;
    uint64_t state;
} JsonBuilderMark;

typedef struct {
    /**
     * config: log flags
     */
    uint8_t log_flags;
} AppLayerTxConfig;

/**
 * LoggerFlags tracks which loggers have already been executed.
 */
typedef struct {
    uint32_t flags;
} LoggerFlags;

typedef struct {
    /**
     * config: log flags
     */
    AppLayerTxConfig config;
    /**
     * logger flags for tx logging api
     */
    LoggerFlags logged;
    /**
     * detection engine flags for use by detection engine
     */
    uint64_t detect_flags_ts;
    uint64_t detect_flags_tc;
} AppLayerTxData;

typedef struct {
    int32_t status;
    uint32_t consumed;
    uint32_t needed;
} AppLayerResult;

typedef struct {
    void *tx_ptr;
    uint64_t tx_id;
    bool has_next;
} AppLayerGetTxIterTuple;

extern void HTTP2MimicHttp1Request(void *orig_state, void *new_state);

bool jb_append_float(JsonBuilder *js, double val);

bool jb_append_object(JsonBuilder *jb, const JsonBuilder *obj);

bool jb_append_string(JsonBuilder *js, const char *val);

bool jb_append_string_from_bytes(JsonBuilder *js,
                                 const uint8_t *bytes,
                                 uint32_t len);

bool jb_append_uint(JsonBuilder *js, uint64_t val);

uintptr_t jb_capacity(JsonBuilder *jb);

JsonBuilder *jb_clone(JsonBuilder *js);

bool jb_close(JsonBuilder *js);

void jb_free(JsonBuilder *js);

void jb_get_mark(JsonBuilder *js, JsonBuilderMark *mark);

uintptr_t jb_len(const JsonBuilder *js);

JsonBuilder *jb_new_array(void);

JsonBuilder *jb_new_object(void);

bool jb_open_array(JsonBuilder *js, const char *key);

bool jb_open_object(JsonBuilder *js, const char *key);

const uint8_t *jb_ptr(JsonBuilder *js);

void jb_reset(JsonBuilder *jb);

bool jb_restore_mark(JsonBuilder *js, JsonBuilderMark *mark);

bool jb_set_bool(JsonBuilder *js, const char *key, bool val);

bool jb_set_float(JsonBuilder *js, const char *key, double val);

bool jb_set_formatted(JsonBuilder *js, const char *formatted);

bool jb_set_object(JsonBuilder *js, const char *key, JsonBuilder *val);

bool jb_set_string(JsonBuilder *js, const char *key, const char *val);

bool jb_set_string_from_bytes(JsonBuilder *js,
                              const char *key,
                              const uint8_t *bytes,
                              uint32_t len);

bool jb_set_uint(JsonBuilder *js, const char *key, uint64_t val);

bool jb_start_object(JsonBuilder *js);

AppProto ntp_probing_parser(const Flow *_flow,
                            uint8_t _direction,
                            const uint8_t *input,
                            uint32_t input_len,
                            uint8_t *_rdir);

/**
 * This function implements the detection of the following options:
 *   - oversize_length
 *   - bitstring_overflow
 *   - double_overflow
 *
 * # Safety
 *
 * ptr must be a valid object obtained using `rs_asn1_decode`
 * ad_ptr must be a valid object obtained using `rs_detect_asn1_parse`
 *
 * Returns 1 if any of the options match, 0 if not
 */
uint8_t rs_asn1_checks(const Asn1 *ptr, const DetectAsn1Data *ad_ptr);

/**
 * Attempt to parse a Asn1 object from input, and return a pointer
 * to the parsed object if successful, null on failure
 *
 * # Safety
 *
 * input must be a valid buffer of at least input_len bytes
 * pointer must be freed using `rs_asn1_free`
 */
Asn1 *rs_asn1_decode(const uint8_t *input,
                     uint16_t input_len,
                     uint32_t buffer_offset,
                     const DetectAsn1Data *ad_ptr);

/**
 * Free a Asn1 object allocated by Rust
 *
 * # Safety
 *
 * ptr must be a valid object obtained using `rs_asn1_decode`
 */
void rs_asn1_free(Asn1 *ptr);

bool rs_check_utf8(const char *val);

/**
 * Free a CString allocated by Rust (for ex. using `rust_string_to_c`)
 *
 * # Safety
 *
 * s must be allocated by rust, using `CString::new`
 */
void rs_cstring_free(char *s);

uint8_t rs_dcerpc_get_alstate_progress(DCERPCTransaction *tx,
                                       uint8_t direction);

uint8_t rs_dcerpc_get_alstate_progress_completion_status(uint8_t _direction);

void rs_dcerpc_get_stub_data(DCERPCTransaction *tx,
                             const uint8_t **buf,
                             uint32_t *len,
                             uint8_t *endianness,
                             uint8_t dir);

DCERPCTransaction *rs_dcerpc_get_tx(void *vtx, uint32_t tx_id);

uint32_t rs_dcerpc_get_tx_cnt(void *vtx);

AppLayerTxData *rs_dcerpc_get_tx_data(void *tx);

DetectEngineState *rs_dcerpc_get_tx_detect_state(void *vtx);

void rs_dcerpc_iface_free(void *ptr);

uint8_t rs_dcerpc_iface_match(DCERPCTransaction *tx,
                              DCERPCState *state,
                              DCEIfaceData *if_data);

void *rs_dcerpc_iface_parse(const char *carg);

bool rs_dcerpc_log_json_record(const DCERPCState *state,
                               const DCERPCTransaction *tx,
                               JsonBuilder *jsb);

void rs_dcerpc_opnum_free(void *ptr);

uint8_t rs_dcerpc_opnum_match(DCERPCTransaction *tx, DCEOpnumData *opnum_data);

void *rs_dcerpc_opnum_parse(const char *carg);

AppLayerResult rs_dcerpc_parse_request(Flow *_flow,
                                       DCERPCState *state,
                                       void *_pstate,
                                       const uint8_t *input,
                                       uint32_t input_len,
                                       void *_data,
                                       uint8_t flags);

AppLayerResult rs_dcerpc_parse_response(Flow *_flow,
                                        DCERPCState *state,
                                        void *_pstate,
                                        const uint8_t *input,
                                        uint32_t input_len,
                                        void *_data,
                                        uint8_t flags);

uint8_t rs_dcerpc_set_tx_detect_state(void *vtx, DetectEngineState *de_state);

void rs_dcerpc_state_free(void *state);

void *rs_dcerpc_state_new(void *_orig_state, AppProto _orig_proto);

void rs_dcerpc_state_transaction_free(void *state, uint64_t tx_id);

void rs_dcerpc_state_trunc(void *state, uint8_t direction);

uint8_t rs_dcerpc_udp_get_alstate_progress(void *_tx, uint8_t _direction);

uint8_t rs_dcerpc_udp_get_alstate_progress_completion_status(uint8_t _direction);

DCERPCUDPState *rs_dcerpc_udp_get_tx(void *state, uint64_t _tx_id);

uint8_t rs_dcerpc_udp_get_tx_cnt(void *_state);

AppLayerTxData *rs_dcerpc_udp_get_tx_data(void *tx);

DetectEngineState *rs_dcerpc_udp_get_tx_detect_state(void *vtx);

AppLayerResult rs_dcerpc_udp_parse(Flow *_flow,
                                   DCERPCUDPState *state,
                                   void *_pstate,
                                   const uint8_t *input,
                                   uint32_t input_len,
                                   void *_data,
                                   uint8_t _flags);

uint8_t rs_dcerpc_udp_set_tx_detect_state(void *vtx,
                                          DetectEngineState *de_state);

void rs_dcerpc_udp_state_free(void *state);

void *rs_dcerpc_udp_state_new(void *_orig_state, AppProto _orig_proto);

void rs_dcerpc_udp_state_transaction_free(void *_state, uint64_t _tx_id);

/**
 * Free a `DetectAsn1Data` object allocated by Rust
 *
 * # Safety
 *
 * ptr must be a valid object obtained using `rs_detect_asn1_parse`
 */
void rs_detect_asn1_free(DetectAsn1Data *ptr);

/**
 * Parse the asn1 keyword and return a pointer to a `DetectAsn1Data`
 * containing the parsed options, returns null on failure
 *
 * # Safety
 *
 * pointer must be free'd using `rs_detect_asn1_free`
 */
DetectAsn1Data *rs_detect_asn1_parse(const char *input);

void *rs_detect_dns_opcode_parse(const char *carg);

void rs_detect_u64_free(void *ctx);

void *rs_detect_u64_parse(const char *str);

bool rs_dhcp_logger_do_log(void *logger, void *tx);

void rs_dhcp_logger_free(void *logger);

bool rs_dhcp_logger_log(void *logger, void *tx, JsonBuilder *js);

void *rs_dhcp_logger_new(const void *conf);

AppLayerResult rs_dhcp_parse(const Flow *_flow,
                             void *state,
                             void *_pstate,
                             const uint8_t *input,
                             uint32_t input_len,
                             const void *_data,
                             uint8_t _flags);

AppProto rs_dhcp_probing_parser(const Flow *_flow,
                                uint8_t _direction,
                                const uint8_t *input,
                                uint32_t input_len,
                                uint8_t *_rdir);

void rs_dhcp_register_parser(void);

void rs_dhcp_state_free(void *state);

int rs_dhcp_state_get_event_info(const char *event_name,
                                 int *event_id,
                                 AppLayerEventType *event_type);

int8_t rs_dhcp_state_get_event_info_by_id(int event_id,
                                          const char **event_name,
                                          AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_dhcp_state_get_events(void *tx);

void *rs_dhcp_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_dhcp_state_get_tx_count(void *state);

AppLayerGetTxIterTuple rs_dhcp_state_get_tx_iterator(uint8_t _ipproto,
                                                     AppProto _alproto,
                                                     void *state,
                                                     uint64_t min_tx_id,
                                                     uint64_t _max_tx_id,
                                                     uint64_t *istate);

void *rs_dhcp_state_new(void *_orig_state, AppProto _orig_proto);

int rs_dhcp_state_progress_completion_status(uint8_t _direction);

void rs_dhcp_state_tx_free(void *state, uint64_t tx_id);

int rs_dhcp_tx_get_alstate_progress(void *_tx, uint8_t _direction);

void rs_dns_apply_tx_config(void *_state,
                            void *_tx,
                            int _mode,
                            AppLayerTxConfig config);

void rs_dns_detect_opcode_free(void *ptr);

bool rs_dns_do_log_answer(RSDNSTransaction *tx, uint64_t flags);

void rs_dns_init(AppProto proto);

bool rs_dns_log_json_answer(RSDNSTransaction *tx,
                            uint64_t flags,
                            JsonBuilder *js);

JsonBuilder *rs_dns_log_json_answer_v1(RSDNSTransaction *tx,
                                       uint16_t i,
                                       uint64_t flags);

JsonBuilder *rs_dns_log_json_authority_v1(RSDNSTransaction *tx,
                                          uint16_t i,
                                          uint64_t flags);

bool rs_dns_log_json_query(RSDNSTransaction *tx,
                           uint16_t i,
                           uint64_t flags,
                           JsonBuilder *jb);

int rs_dns_lua_get_answer_table(lua_State *clua, RSDNSTransaction *tx);

int rs_dns_lua_get_authority_table(lua_State *clua, RSDNSTransaction *tx);

int rs_dns_lua_get_query_table(lua_State *clua, RSDNSTransaction *tx);

int rs_dns_lua_get_rcode(lua_State *clua, RSDNSTransaction *tx);

int rs_dns_lua_get_rrname(lua_State *clua, RSDNSTransaction *tx);

void rs_dns_lua_get_tx_id(lua_State *clua, RSDNSTransaction *tx);

/**
 * Perform the DNS opcode match.
 *
 * 1 will be returned on match, otherwise 0 will be returned.
 */
uint8_t rs_dns_opcode_match(RSDNSTransaction *tx,
                            DetectDnsOpcode *detect,
                            uint8_t flags);

/**
 * C binding parse a DNS request. Returns 1 on success, -1 on failure.
 */
AppLayerResult rs_dns_parse_request(const Flow *_flow,
                                    void *state,
                                    void *_pstate,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    const void *_data,
                                    uint8_t _flags);

/**
 * C binding parse a DNS request. Returns 1 on success, -1 on failure.
 */
AppLayerResult rs_dns_parse_request_tcp(const Flow *_flow,
                                        void *state,
                                        void *_pstate,
                                        const uint8_t *input,
                                        uint32_t input_len,
                                        const void *_data,
                                        uint8_t _flags);

AppLayerResult rs_dns_parse_response(const Flow *_flow,
                                     void *state,
                                     void *_pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     const void *_data,
                                     uint8_t _flags);

AppLayerResult rs_dns_parse_response_tcp(const Flow *_flow,
                                         void *state,
                                         void *_pstate,
                                         const uint8_t *input,
                                         uint32_t input_len,
                                         const void *_data,
                                         uint8_t _flags);

AppProto rs_dns_probe(const Flow *_flow,
                      uint8_t _dir,
                      const uint8_t *input,
                      uint32_t len,
                      uint8_t *rdir);

AppProto rs_dns_probe_tcp(const Flow *_flow,
                          uint8_t direction,
                          const uint8_t *input,
                          uint32_t len,
                          uint8_t *rdir);

/**
 * Params:
 * - state: *mut DNSState as void pointer
 */
void rs_dns_state_free(void *state);

int rs_dns_state_get_event_info(const char *event_name,
                                int *event_id,
                                AppLayerEventType *event_type);

int8_t rs_dns_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_dns_state_get_events(void *tx);

void *rs_dns_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_dns_state_get_tx_count(void *state);

AppLayerTxData *rs_dns_state_get_tx_data(void *tx);

DetectEngineState *rs_dns_state_get_tx_detect_state(void *tx);

/**
 * Returns *mut DNSState
 */
void *rs_dns_state_new(void *_orig_state, AppProto _orig_proto);

int rs_dns_state_progress_completion_status(uint8_t _direction);

int rs_dns_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

/**
 * Returns *mut DNSState
 */
void *rs_dns_state_tcp_new(void);

void rs_dns_state_tx_free(void *state, uint64_t tx_id);

void rs_dns_tcp_register_parser(void);

int rs_dns_tx_get_alstate_progress(void *_tx, uint8_t _direction);

uint8_t rs_dns_tx_get_query_name(RSDNSTransaction *tx,
                                 uint16_t i,
                                 const uint8_t **buf,
                                 uint32_t *len);

uint8_t rs_dns_tx_get_query_rrtype(RSDNSTransaction *tx,
                                   uint16_t i,
                                   uint16_t *rrtype);

/**
 * Get the DNS response flags for a transaction.
 *
 * extern uint16_t rs_dns_tx_get_response_flags(RSDNSTransaction *);
 */
uint16_t rs_dns_tx_get_response_flags(RSDNSTransaction *tx);

/**
 * Get the DNS transaction ID of a transaction.
 * extern uint16_t rs_dns_tx_get_tx_id(RSDNSTransaction *);
 */
uint16_t rs_dns_tx_get_tx_id(RSDNSTransaction *tx);

void rs_dns_udp_register_parser(void);

uint16_t rs_ftp_active_eprt(const uint8_t *input, uint32_t len);

uint16_t rs_ftp_active_port(const uint8_t *input, uint32_t len);

uint16_t rs_ftp_epsv_response(const uint8_t *input, uint32_t len);

uint16_t rs_ftp_pasv_response(const uint8_t *input, uint32_t len);

void rs_http2_detect_settingsctx_free(void *ctx);

int rs_http2_detect_settingsctx_match(const void *ctx,
                                      void *tx,
                                      uint8_t direction);

void *rs_http2_detect_settingsctx_parse(const char *str);

int rs_http2_detect_sizeupdatectx_match(const void *ctx,
                                        void *tx,
                                        uint8_t direction);

FileContainer *rs_http2_getfiles(void *state, uint8_t direction);

void rs_http2_init(SuricataFileContext *context);

bool rs_http2_log_json(void *tx, JsonBuilder *js);

int rs_http2_parse_errorcode(const char *str);

int rs_http2_parse_frametype(const char *str);

int rs_http2_parse_settingsid(const char *str);

AppLayerResult rs_http2_parse_tc(const Flow *flow,
                                 void *state,
                                 void *_pstate,
                                 const uint8_t *input,
                                 uint32_t input_len,
                                 const void *_data,
                                 uint8_t _flags);

AppLayerResult rs_http2_parse_ts(const Flow *flow,
                                 void *state,
                                 void *_pstate,
                                 const uint8_t *input,
                                 uint32_t input_len,
                                 const void *_data,
                                 uint8_t _flags);

/**
 * C entry point for a probing parser.
 */
AppProto rs_http2_probing_parser_tc(const Flow *_flow,
                                    uint8_t _direction,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    uint8_t *_rdir);

void rs_http2_register_parser(void);

void rs_http2_state_free(void *state);

int rs_http2_state_get_event_info(const char *event_name,
                                  int *event_id,
                                  AppLayerEventType *event_type);

int8_t rs_http2_state_get_event_info_by_id(int event_id,
                                           const char **event_name,
                                           AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_http2_state_get_events(void *tx);

void *rs_http2_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_http2_state_get_tx_count(void *state);

AppLayerGetTxIterTuple rs_http2_state_get_tx_iterator(uint8_t _ipproto,
                                                      AppProto _alproto,
                                                      void *state,
                                                      uint64_t min_tx_id,
                                                      uint64_t _max_tx_id,
                                                      uint64_t *istate);

void *rs_http2_state_new(void *orig_state, AppProto _orig_proto);

int rs_http2_state_progress_completion_status(uint8_t _direction);

void rs_http2_state_tx_free(void *state, uint64_t tx_id);

void rs_http2_tx_add_header(HTTP2State *state,
                            const uint8_t *name,
                            uint32_t name_len,
                            const uint8_t *value,
                            uint32_t value_len);

int rs_http2_tx_get_alstate_progress(void *tx, uint8_t _direction);

uint8_t rs_http2_tx_get_header(HTTP2Transaction *tx,
                               uint8_t direction,
                               uint32_t nb,
                               const uint8_t **buffer,
                               uint32_t *buffer_len);

uint8_t rs_http2_tx_get_header_name(HTTP2Transaction *tx,
                                    uint8_t direction,
                                    uint32_t nb,
                                    const uint8_t **buffer,
                                    uint32_t *buffer_len);

int rs_http2_tx_get_next_priority(void *tx, uint8_t direction, uint32_t nb);

int rs_http2_tx_get_next_window(void *tx, uint8_t direction, uint32_t nb);

HTTP2TransactionState rs_http2_tx_get_state(void *tx);

int rs_http2_tx_has_errorcode(void *tx, uint8_t direction, uint32_t code);

int rs_http2_tx_has_frametype(void *tx, uint8_t direction, uint8_t value);

void rs_http2_tx_set_method(HTTP2State *state,
                            const uint8_t *buffer,
                            uint32_t buffer_len);

void rs_http2_tx_set_uri(HTTP2State *state,
                         const uint8_t *buffer,
                         uint32_t buffer_len);

bool rs_ikev2_log_json_response(IKEV2State *state,
                                IKEV2Transaction *tx,
                                JsonBuilder *jb);

AppLayerResult rs_ikev2_parse_request(const Flow *_flow,
                                      void *state,
                                      void *_pstate,
                                      const uint8_t *input,
                                      uint32_t input_len,
                                      const void *_data,
                                      uint8_t _flags);

AppLayerResult rs_ikev2_parse_response(const Flow *_flow,
                                       void *state,
                                       void *pstate,
                                       const uint8_t *input,
                                       uint32_t input_len,
                                       const void *_data,
                                       uint8_t _flags);

AppProto rs_ikev2_probing_parser(const Flow *_flow,
                                 uint8_t _direction,
                                 const uint8_t *input,
                                 uint32_t input_len,
                                 uint8_t *_rdir);

/**
 * Params:
 * - state: *mut IKEV2State as void pointer
 */
void rs_ikev2_state_free(void *state);

int rs_ikev2_state_get_event_info(const char *event_name,
                                  int *event_id,
                                  AppLayerEventType *event_type);

int8_t rs_ikev2_state_get_event_info_by_id(int event_id,
                                           const char **event_name,
                                           AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_ikev2_state_get_events(void *tx);

void *rs_ikev2_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_ikev2_state_get_tx_count(void *state);

DetectEngineState *rs_ikev2_state_get_tx_detect_state(void *tx);

/**
 * Returns *mut IKEV2State
 */
void *rs_ikev2_state_new(void *_orig_state, AppProto _orig_proto);

int rs_ikev2_state_progress_completion_status(uint8_t _direction);

int rs_ikev2_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_ikev2_state_tx_free(void *state, uint64_t tx_id);

int rs_ikev2_tx_get_alstate_progress(void *_tx, uint8_t _direction);

void rs_init(SuricataContext *context);

bool rs_krb5_log_json_response(JsonBuilder *jsb,
                               KRB5State *_state,
                               KRB5Transaction *tx);

AppLayerResult rs_krb5_parse_request(const Flow *_flow,
                                     void *state,
                                     void *_pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     const void *_data,
                                     uint8_t _flags);

AppLayerResult rs_krb5_parse_request_tcp(const Flow *_flow,
                                         void *state,
                                         void *_pstate,
                                         const uint8_t *input,
                                         uint32_t input_len,
                                         const void *_data,
                                         uint8_t _flags);

AppLayerResult rs_krb5_parse_response(const Flow *_flow,
                                      void *state,
                                      void *_pstate,
                                      const uint8_t *input,
                                      uint32_t input_len,
                                      const void *_data,
                                      uint8_t _flags);

AppLayerResult rs_krb5_parse_response_tcp(const Flow *_flow,
                                          void *state,
                                          void *_pstate,
                                          const uint8_t *input,
                                          uint32_t input_len,
                                          const void *_data,
                                          uint8_t _flags);

AppProto rs_krb5_probing_parser(const Flow *_flow,
                                uint8_t _direction,
                                const uint8_t *input,
                                uint32_t input_len,
                                uint8_t *_rdir);

AppProto rs_krb5_probing_parser_tcp(const Flow *_flow,
                                    uint8_t direction,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    uint8_t *rdir);

/**
 * Params:
 * - state: *mut KRB5State as void pointer
 */
void rs_krb5_state_free(void *state);

int rs_krb5_state_get_event_info(const char *event_name,
                                 int *event_id,
                                 AppLayerEventType *event_type);

int8_t rs_krb5_state_get_event_info_by_id(int event_id,
                                          const char **event_name,
                                          AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_krb5_state_get_events(void *tx);

void *rs_krb5_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_krb5_state_get_tx_count(void *state);

DetectEngineState *rs_krb5_state_get_tx_detect_state(void *tx);

/**
 * Returns *mut KRB5State
 */
void *rs_krb5_state_new(void *_orig_state, AppProto _orig_proto);

int rs_krb5_state_progress_completion_status(uint8_t _direction);

int rs_krb5_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_krb5_state_tx_free(void *state, uint64_t tx_id);

int rs_krb5_tx_get_alstate_progress(void *_tx, uint8_t _direction);

uint8_t rs_krb5_tx_get_cname(KRB5Transaction *tx,
                             uint16_t i,
                             const uint8_t **buffer,
                             uint32_t *buffer_len);

/**
 * Get error code, if present in transaction
 * Return 0 if error code was filled, else 1
 */
uint32_t rs_krb5_tx_get_errcode(KRB5Transaction *tx, int32_t *ptr);

void rs_krb5_tx_get_msgtype(KRB5Transaction *tx, uint32_t *ptr);

uint8_t rs_krb5_tx_get_sname(KRB5Transaction *tx,
                             uint16_t i,
                             const uint8_t **buffer,
                             uint32_t *buffer_len);

void rs_log_set_level(int32_t level);

int rs_mqtt_cstr_message_code(const char *str);

bool rs_mqtt_logger_log(MQTTState *_state,
                        void *tx,
                        uint32_t flags,
                        JsonBuilder *js);

AppLayerResult rs_mqtt_parse_request(const Flow *_flow,
                                     void *state,
                                     void *_pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     const void *_data,
                                     uint8_t _flags);

AppLayerResult rs_mqtt_parse_response(const Flow *_flow,
                                      void *state,
                                      void *_pstate,
                                      const uint8_t *input,
                                      uint32_t input_len,
                                      const void *_data,
                                      uint8_t _flags);

AppProto rs_mqtt_probing_parser(const Flow *_flow,
                                uint8_t _direction,
                                const uint8_t *input,
                                uint32_t input_len,
                                uint8_t *_rdir);

void rs_mqtt_register_parser(uint32_t cfg_max_msg_len);

void rs_mqtt_state_free(void *state);

int rs_mqtt_state_get_event_info(const char *event_name,
                                 int *event_id,
                                 AppLayerEventType *event_type);

int8_t rs_mqtt_state_get_event_info_by_id(int event_id,
                                          const char **event_name,
                                          AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_mqtt_state_get_events(void *tx);

void *rs_mqtt_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_mqtt_state_get_tx_count(void *state);

AppLayerGetTxIterTuple rs_mqtt_state_get_tx_iterator(uint8_t _ipproto,
                                                     AppProto _alproto,
                                                     void *state,
                                                     uint64_t min_tx_id,
                                                     uint64_t _max_tx_id,
                                                     uint64_t *istate);

void *rs_mqtt_state_new(void *_orig_state, AppProto _orig_proto);

int rs_mqtt_state_progress_completion_status(uint8_t _direction);

void rs_mqtt_state_tx_free(void *state, uint64_t tx_id);

int rs_mqtt_tx_get_alstate_progress(void *tx, uint8_t direction);

uint8_t rs_mqtt_tx_get_connack_sessionpresent(const MQTTTransaction *tx,
                                              bool *session_present);

uint8_t rs_mqtt_tx_get_connect_clientid(const MQTTTransaction *tx,
                                        const uint8_t **buffer,
                                        uint32_t *buffer_len);

uint8_t rs_mqtt_tx_get_connect_password(const MQTTTransaction *tx,
                                        const uint8_t **buffer,
                                        uint32_t *buffer_len);

uint8_t rs_mqtt_tx_get_connect_username(const MQTTTransaction *tx,
                                        const uint8_t **buffer,
                                        uint32_t *buffer_len);

uint8_t rs_mqtt_tx_get_connect_willmessage(const MQTTTransaction *tx,
                                           const uint8_t **buffer,
                                           uint32_t *buffer_len);

uint8_t rs_mqtt_tx_get_connect_willtopic(const MQTTTransaction *tx,
                                         const uint8_t **buffer,
                                         uint32_t *buffer_len);

uint32_t rs_mqtt_tx_get_logged(void *_state, void *tx);

uint8_t rs_mqtt_tx_get_protocol_version(const MQTTState *state);

uint8_t rs_mqtt_tx_get_publish_message(const MQTTTransaction *tx,
                                       const uint8_t **buffer,
                                       uint32_t *buffer_len);

uint8_t rs_mqtt_tx_get_publish_topic(const MQTTTransaction *tx,
                                     const uint8_t **buffer,
                                     uint32_t *buffer_len);

uint8_t rs_mqtt_tx_get_reason_code(const MQTTTransaction *tx, uint8_t *result);

uint8_t rs_mqtt_tx_get_subscribe_topic(const MQTTTransaction *tx,
                                       uint16_t i,
                                       const uint8_t **buf,
                                       uint32_t *len);

uint8_t rs_mqtt_tx_get_unsubscribe_topic(const MQTTTransaction *tx,
                                         uint16_t i,
                                         const uint8_t **buf,
                                         uint32_t *len);

uint8_t rs_mqtt_tx_has_connect_flags(const MQTTTransaction *tx,
                                     MQTTFlagState username,
                                     MQTTFlagState password,
                                     MQTTFlagState will,
                                     MQTTFlagState will_retain,
                                     MQTTFlagState clean_session);

uint8_t rs_mqtt_tx_has_flags(const MQTTTransaction *tx,
                             MQTTFlagState qretain,
                             MQTTFlagState qdup);

uint8_t rs_mqtt_tx_has_qos(const MQTTTransaction *tx, uint8_t qos);

uint8_t rs_mqtt_tx_has_type(const MQTTTransaction *tx, uint8_t mtype);

int rs_mqtt_tx_is_toclient(const void *tx);

void rs_mqtt_tx_set_logged(void *_state, void *tx, uint32_t logged);

uint8_t rs_mqtt_tx_unsuback_has_reason_code(const MQTTTransaction *tx,
                                            uint8_t code);

AppLayerTxData *rs_nfs_get_tx_data(void *tx);

FileContainer *rs_nfs_getfiles(uint8_t direction, NFSState *ptr);

void rs_nfs_init(SuricataFileContext *context);

bool rs_nfs_log_json_request(NFSState *state,
                             NFSTransaction *tx,
                             JsonBuilder *js);

bool rs_nfs_log_json_response(NFSState *state,
                              NFSTransaction *tx,
                              JsonBuilder *js);

/**
 * C binding parse a NFS TCP request. Returns 1 on success, -1 on failure.
 */
AppLayerResult rs_nfs_parse_request(Flow *flow,
                                    NFSState *state,
                                    void *_pstate,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    void *_data);

AppLayerResult rs_nfs_parse_request_tcp_gap(NFSState *state,
                                            uint32_t input_len);

/**
 * C binding parse a DNS request. Returns 1 on success, -1 on failure.
 */
AppLayerResult rs_nfs_parse_request_udp(Flow *_flow,
                                        NFSState *state,
                                        void *_pstate,
                                        const uint8_t *input,
                                        uint32_t input_len,
                                        void *_data);

AppLayerResult rs_nfs_parse_response(Flow *flow,
                                     NFSState *state,
                                     void *_pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     void *_data);

AppLayerResult rs_nfs_parse_response_tcp_gap(NFSState *state,
                                             uint32_t input_len);

AppLayerResult rs_nfs_parse_response_udp(Flow *_flow,
                                         NFSState *state,
                                         void *_pstate,
                                         const uint8_t *input,
                                         uint32_t input_len,
                                         void *_data);

int8_t rs_nfs_probe(uint8_t direction, const uint8_t *input, uint32_t len);

/**
 * MIDSTREAM
 */
int8_t rs_nfs_probe_ms(uint8_t direction,
                       const uint8_t *input,
                       uint32_t len,
                       uint8_t *rdir);

/**
 * TOCLIENT probe function
 */
int8_t rs_nfs_probe_udp_tc(const uint8_t *input, uint32_t len);

/**
 * TOSERVER probe function
 */
int8_t rs_nfs_probe_udp_ts(const uint8_t *input, uint32_t len);

void rs_nfs_setfileflags(uint8_t direction, NFSState *ptr, uint16_t flags);

/**
 * Params:
 * - state: *mut NFSState as void pointer
 */
void rs_nfs_state_free(void *state);

int8_t rs_nfs_state_get_event_info(const char *event_name,
                                   int *event_id,
                                   AppLayerEventType *event_type);

int8_t rs_nfs_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_nfs_state_get_events(void *tx);

NFSTransaction *rs_nfs_state_get_tx(NFSState *state, uint64_t tx_id);

uint64_t rs_nfs_state_get_tx_count(NFSState *state);

DetectEngineState *rs_nfs_state_get_tx_detect_state(NFSTransaction *tx);

AppLayerGetTxIterTuple rs_nfs_state_get_tx_iterator(NFSState *state,
                                                    uint64_t min_tx_id,
                                                    uint64_t *istate);

/**
 * Returns *mut NFSState
 */
void *rs_nfs_state_new(void *_orig_state, AppProto _orig_proto);

int rs_nfs_state_progress_completion_status(uint8_t _direction);

void rs_nfs_state_set_tx_detect_state(NFSTransaction *tx,
                                      DetectEngineState *de_state);

void rs_nfs_state_tx_free(NFSState *state, uint64_t tx_id);

uint8_t rs_nfs_tx_get_alstate_progress(NFSTransaction *tx, uint8_t direction);

/**
 * return procedure(s) in the tx. At 0 return the main proc,
 * otherwise get procs from the 'file_additional_procs'.
 * Keep calling until 0 is returned.
 */
uint8_t rs_nfs_tx_get_procedures(NFSTransaction *tx,
                                 uint16_t i,
                                 uint32_t *procedure);

void rs_nfs_tx_get_version(NFSTransaction *tx, uint32_t *version);

uint8_t rs_nfs_tx_logging_is_filtered(NFSState *state, NFSTransaction *tx);

AppLayerResult rs_ntp_parse_request(const Flow *_flow,
                                    void *state,
                                    void *_pstate,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    const void *_data,
                                    uint8_t _flags);

AppLayerResult rs_ntp_parse_response(const Flow *_flow,
                                     void *state,
                                     void *_pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     const void *_data,
                                     uint8_t _flags);

/**
 * Params:
 * - state: *mut NTPState as void pointer
 */
void rs_ntp_state_free(void *state);

int rs_ntp_state_get_event_info(const char *event_name,
                                int *event_id,
                                AppLayerEventType *event_type);

int8_t rs_ntp_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_ntp_state_get_events(void *tx);

void *rs_ntp_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_ntp_state_get_tx_count(void *state);

DetectEngineState *rs_ntp_state_get_tx_detect_state(void *tx);

/**
 * Returns *mut NTPState
 */
void *rs_ntp_state_new(void *_orig_state, AppProto _orig_proto);

int rs_ntp_state_progress_completion_status(uint8_t _direction);

int rs_ntp_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_ntp_state_tx_free(void *state, uint64_t tx_id);

int rs_ntp_tx_get_alstate_progress(void *_tx, uint8_t _direction);

AppLayerResult rs_parse_dcerpc_request_gap(DCERPCState *state,
                                           uint32_t _input_len);

AppLayerResult rs_parse_dcerpc_response_gap(DCERPCState *state,
                                            uint32_t _input_len);

AppLayerResult rs_rdp_parse_tc(const Flow *_flow,
                               void *state,
                               void *_pstate,
                               const uint8_t *input,
                               uint32_t input_len,
                               const void *_data,
                               uint8_t _flags);

AppLayerResult rs_rdp_parse_ts(const Flow *_flow,
                               void *state,
                               void *_pstate,
                               const uint8_t *input,
                               uint32_t input_len,
                               const void *_data,
                               uint8_t _flags);

/**
 * probe for T.123 message, whether to client or to server
 */
AppProto rs_rdp_probe_ts_tc(const Flow *_flow,
                            uint8_t _direction,
                            const uint8_t *input,
                            uint32_t input_len,
                            uint8_t *_rdir);

void rs_rdp_register_parser(void);

void rs_rdp_state_free(void *state);

void *rs_rdp_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_rdp_state_get_tx_count(void *state);

void *rs_rdp_state_new(void *_orig_state, AppProto _orig_proto);

void rs_rdp_state_tx_free(void *state, uint64_t tx_id);

bool rs_rdp_to_json(RdpTransaction *tx, JsonBuilder *js);

int rs_rdp_tx_get_progress(void *_tx, uint8_t _direction);

int rs_rdp_tx_get_progress_complete(uint8_t _direction);

void rs_register_ikev2_parser(void);

void rs_register_krb5_parser(void);

void rs_register_ntp_parser(void);

void rs_register_snmp_parser(void);

bool rs_rfb_logger_log(RFBState *_state, void *tx, JsonBuilder *js);

AppLayerResult rs_rfb_parse_request(const Flow *_flow,
                                    void *state,
                                    void *_pstate,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    const void *_data,
                                    uint8_t _flags);

AppLayerResult rs_rfb_parse_response(const Flow *_flow,
                                     void *state,
                                     void *_pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     const void *_data,
                                     uint8_t _flags);

void rs_rfb_register_parser(void);

void rs_rfb_state_free(void *state);

int rs_rfb_state_get_event_info(const char *_event_name,
                                int *_event_id,
                                AppLayerEventType *_event_type);

int8_t rs_rfb_state_get_event_info_by_id(int _event_id,
                                         const char **_event_name,
                                         AppLayerEventType *_event_type);

AppLayerDecoderEvents *rs_rfb_state_get_events(void *tx);

void *rs_rfb_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_rfb_state_get_tx_count(void *state);

AppLayerGetTxIterTuple rs_rfb_state_get_tx_iterator(uint8_t _ipproto,
                                                    AppProto _alproto,
                                                    void *state,
                                                    uint64_t min_tx_id,
                                                    uint64_t _max_tx_id,
                                                    uint64_t *istate);

void *rs_rfb_state_new(void *_orig_state, AppProto _orig_proto);

int rs_rfb_state_progress_completion_status(uint8_t _direction);

void rs_rfb_state_tx_free(void *state, uint64_t tx_id);

int rs_rfb_tx_get_alstate_progress(void *tx, uint8_t _direction);

uint8_t rs_rfb_tx_get_name(RFBTransaction *tx,
                           const uint8_t **buffer,
                           uint32_t *buffer_len);

uint8_t rs_rfb_tx_get_secresult(RFBTransaction *tx, uint32_t *secresult);

uint8_t rs_rfb_tx_get_sectype(RFBTransaction *tx, uint32_t *sectype);

bool rs_rpc_log_json_response(NFSTransaction *tx, JsonBuilder *js);

bool rs_sip_log_json(SIPTransaction *tx, JsonBuilder *js);

AppLayerResult rs_sip_parse_request(const Flow *_flow,
                                    void *state,
                                    void *_pstate,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    const void *_data,
                                    uint8_t _flags);

AppLayerResult rs_sip_parse_response(const Flow *_flow,
                                     void *state,
                                     void *_pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     const void *_data,
                                     uint8_t _flags);

AppProto rs_sip_probing_parser_tc(const Flow *_flow,
                                  uint8_t _direction,
                                  const uint8_t *input,
                                  uint32_t input_len,
                                  uint8_t *_rdir);

AppProto rs_sip_probing_parser_ts(const Flow *_flow,
                                  uint8_t _direction,
                                  const uint8_t *input,
                                  uint32_t input_len,
                                  uint8_t *_rdir);

void rs_sip_register_parser(void);

void rs_sip_state_free(void *state);

int rs_sip_state_get_event_info(const char *event_name,
                                int *event_id,
                                AppLayerEventType *event_type);

int8_t rs_sip_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_sip_state_get_events(void *tx);

void *rs_sip_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_sip_state_get_tx_count(void *state);

DetectEngineState *rs_sip_state_get_tx_detect_state(void *tx);

void *rs_sip_state_new(void *_orig_state, AppProto _orig_proto);

int rs_sip_state_progress_completion_status(uint8_t _direction);

int rs_sip_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_sip_state_tx_free(void *state, uint64_t tx_id);

int rs_sip_tx_get_alstate_progress(void *_tx, uint8_t _direction);

uint8_t rs_sip_tx_get_method(SIPTransaction *tx,
                             const uint8_t **buffer,
                             uint32_t *buffer_len);

uint8_t rs_sip_tx_get_protocol(SIPTransaction *tx,
                               const uint8_t **buffer,
                               uint32_t *buffer_len,
                               uint8_t direction);

uint8_t rs_sip_tx_get_request_line(SIPTransaction *tx,
                                   const uint8_t **buffer,
                                   uint32_t *buffer_len);

uint8_t rs_sip_tx_get_response_line(SIPTransaction *tx,
                                    const uint8_t **buffer,
                                    uint32_t *buffer_len);

uint8_t rs_sip_tx_get_stat_code(SIPTransaction *tx,
                                const uint8_t **buffer,
                                uint32_t *buffer_len);

uint8_t rs_sip_tx_get_stat_msg(SIPTransaction *tx,
                               const uint8_t **buffer,
                               uint32_t *buffer_len);

uint8_t rs_sip_tx_get_uri(SIPTransaction *tx,
                          const uint8_t **buffer,
                          uint32_t *buffer_len);

AppLayerTxData *rs_smb_get_tx_data(void *tx);

FileContainer *rs_smb_getfiles(uint8_t direction, SMBState *ptr);

void rs_smb_init(SuricataFileContext *context);

bool rs_smb_log_json_request(JsonBuilder *jsb,
                             SMBState *state,
                             SMBTransaction *tx);

bool rs_smb_log_json_response(JsonBuilder *jsb,
                              SMBState *state,
                              SMBTransaction *tx);

/**
 * C binding parse a SMB request. Returns 1 on success, -1 on failure.
 */
AppLayerResult rs_smb_parse_request_tcp(Flow *flow,
                                        SMBState *state,
                                        void *_pstate,
                                        const uint8_t *input,
                                        uint32_t input_len,
                                        void *_data,
                                        uint8_t flags);

AppLayerResult rs_smb_parse_request_tcp_gap(SMBState *state,
                                            uint32_t input_len);

AppLayerResult rs_smb_parse_response_tcp(Flow *flow,
                                         SMBState *state,
                                         void *_pstate,
                                         const uint8_t *input,
                                         uint32_t input_len,
                                         void *_data,
                                         uint8_t flags);

AppLayerResult rs_smb_parse_response_tcp_gap(SMBState *state,
                                             uint32_t input_len);

int8_t rs_smb_probe_tcp(uint8_t direction,
                        const uint8_t *input,
                        uint32_t len,
                        uint8_t *rdir);

void rs_smb_setfileflags(uint8_t direction, SMBState *ptr, uint16_t flags);

/**
 * Params:
 * - state: *mut SMBState as void pointer
 */
void rs_smb_state_free(void *state);

int8_t rs_smb_state_get_event_info(const char *event_name,
                                   int *event_id,
                                   AppLayerEventType *event_type);

int8_t rs_smb_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_smb_state_get_events(void *tx);

SMBTransaction *rs_smb_state_get_tx(SMBState *state, uint64_t tx_id);

uint64_t rs_smb_state_get_tx_count(SMBState *state);

DetectEngineState *rs_smb_state_get_tx_detect_state(SMBTransaction *tx);

AppLayerGetTxIterTuple rs_smb_state_get_tx_iterator(SMBState *state,
                                                    uint64_t min_tx_id,
                                                    uint64_t *istate);

/**
 * Returns *mut SMBState
 */
void *rs_smb_state_new(void *_orig_state, AppProto _orig_proto);

int rs_smb_state_progress_completion_status(uint8_t _direction);

void rs_smb_state_set_tx_detect_state(SMBTransaction *tx,
                                      DetectEngineState *de_state);

void rs_smb_state_truncate(SMBState *state, uint8_t direction);

void rs_smb_state_tx_free(SMBState *state, uint64_t tx_id);

uint8_t rs_smb_tx_get_alstate_progress(SMBTransaction *tx, uint8_t direction);

uint8_t rs_smb_tx_get_dce_iface(SMBState *state,
                                SMBTransaction *tx,
                                DCEIfaceData *dce_data);

uint8_t rs_smb_tx_get_named_pipe(SMBTransaction *tx,
                                 const uint8_t **buffer,
                                 uint32_t *buffer_len);

uint8_t rs_smb_tx_get_share(SMBTransaction *tx,
                            const uint8_t **buffer,
                            uint32_t *buffer_len);

uint8_t rs_smb_tx_get_stub_data(SMBTransaction *tx,
                                uint8_t direction,
                                const uint8_t **buffer,
                                uint32_t *buffer_len);

uint8_t rs_smb_tx_match_dce_opnum(SMBTransaction *tx, DCEOpnumData *dce_data);

AppLayerGetTxIterTuple rs_snmp_get_tx_iterator(uint8_t _ipproto,
                                               AppProto _alproto,
                                               void *alstate,
                                               uint64_t min_tx_id,
                                               uint64_t _max_tx_id,
                                               uint64_t *istate);

bool rs_snmp_log_json_response(JsonBuilder *jsb,
                               SNMPState *state,
                               SNMPTransaction *tx);

AppLayerResult rs_snmp_parse_request(const Flow *_flow,
                                     void *state,
                                     void *_pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     const void *_data,
                                     uint8_t _flags);

AppLayerResult rs_snmp_parse_response(const Flow *_flow,
                                      void *state,
                                      void *_pstate,
                                      const uint8_t *input,
                                      uint32_t input_len,
                                      const void *_data,
                                      uint8_t _flags);

AppProto rs_snmp_probing_parser(const Flow *_flow,
                                uint8_t _direction,
                                const uint8_t *input,
                                uint32_t input_len,
                                uint8_t *_rdir);

/**
 * Params:
 * - state: *mut SNMPState as void pointer
 */
void rs_snmp_state_free(void *state);

int rs_snmp_state_get_event_info(const char *event_name,
                                 int *event_id,
                                 AppLayerEventType *event_type);

int8_t rs_snmp_state_get_event_info_by_id(int event_id,
                                          const char **event_name,
                                          AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_snmp_state_get_events(void *tx);

void *rs_snmp_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_snmp_state_get_tx_count(void *state);

DetectEngineState *rs_snmp_state_get_tx_detect_state(void *tx);

AppLayerGetTxIterTuple rs_snmp_state_get_tx_iterator(SNMPState *state,
                                                     uint64_t min_tx_id,
                                                     uint64_t *istate);

/**
 * Returns *mut SNMPState
 */
void *rs_snmp_state_new(void *_orig_state, AppProto _orig_proto);

int rs_snmp_state_progress_completion_status(uint8_t _direction);

int rs_snmp_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_snmp_state_tx_free(void *state, uint64_t tx_id);

int rs_snmp_tx_get_alstate_progress(void *_tx, uint8_t _direction);

void rs_snmp_tx_get_community(SNMPTransaction *tx,
                              const uint8_t **buf,
                              uint32_t *len);

void rs_snmp_tx_get_pdu_type(SNMPTransaction *tx, uint32_t *pdu_type);

void rs_snmp_tx_get_version(SNMPTransaction *tx, uint32_t *version);

void rs_ssh_enable_hassh(void);

bool rs_ssh_hassh_is_enabled(void);

bool rs_ssh_log_json(void *tx, JsonBuilder *js);

AppLayerResult rs_ssh_parse_request(const Flow *_flow,
                                    void *state,
                                    void *pstate,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    const void *_data,
                                    uint8_t _flags);

AppLayerResult rs_ssh_parse_response(const Flow *_flow,
                                     void *state,
                                     void *pstate,
                                     const uint8_t *input,
                                     uint32_t input_len,
                                     const void *_data,
                                     uint8_t _flags);

void rs_ssh_register_parser(void);

void rs_ssh_state_free(void *state);

int rs_ssh_state_get_event_info(const char *event_name,
                                int *event_id,
                                AppLayerEventType *event_type);

int8_t rs_ssh_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_ssh_state_get_events(void *tx);

void *rs_ssh_state_get_tx(void *state, uint64_t _tx_id);

uint64_t rs_ssh_state_get_tx_count(void *_state);

void *rs_ssh_state_new(void *_orig_state, AppProto _orig_proto);

int rs_ssh_state_progress_completion_status(uint8_t _direction);

void rs_ssh_state_tx_free(void *_state, uint64_t _tx_id);

int rs_ssh_tx_get_alstate_progress(void *tx, uint8_t direction);

SSHConnectionState rs_ssh_tx_get_flags(void *tx, uint8_t direction);

uint8_t rs_ssh_tx_get_hassh(void *tx,
                            const uint8_t **buffer,
                            uint32_t *buffer_len,
                            uint8_t direction);

uint8_t rs_ssh_tx_get_hassh_string(void *tx,
                                   const uint8_t **buffer,
                                   uint32_t *buffer_len,
                                   uint8_t direction);

bool rs_ssh_tx_get_log_condition(void *tx);

uint8_t rs_ssh_tx_get_protocol(void *tx,
                               const uint8_t **buffer,
                               uint32_t *buffer_len,
                               uint8_t direction);

uint8_t rs_ssh_tx_get_software(void *tx,
                               const uint8_t **buffer,
                               uint32_t *buffer_len,
                               uint8_t direction);

/**
 * Get the request buffer for a transaction from C.
 *
 * No required for parsing, but an example function for retrieving a
 * pointer to the request buffer from C for detection.
 */
uint8_t rs_template_get_request_buffer(void *tx,
                                       const uint8_t **buf,
                                       uint32_t *len);

/**
 * Get the response buffer for a transaction from C.
 */
uint8_t rs_template_get_response_buffer(void *tx,
                                        const uint8_t **buf,
                                        uint32_t *len);

bool rs_template_logger_log(void *tx, JsonBuilder *js);

AppLayerResult rs_template_parse_request(const Flow *_flow,
                                         void *state,
                                         void *pstate,
                                         const uint8_t *input,
                                         uint32_t input_len,
                                         const void *_data,
                                         uint8_t _flags);

AppLayerResult rs_template_parse_response(const Flow *_flow,
                                          void *state,
                                          void *pstate,
                                          const uint8_t *input,
                                          uint32_t input_len,
                                          const void *_data,
                                          uint8_t _flags);

/**
 * C entry point for a probing parser.
 */
AppProto rs_template_probing_parser(const Flow *_flow,
                                    uint8_t _direction,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    uint8_t *_rdir);

void rs_template_register_parser(void);

void rs_template_state_free(void *state);

int rs_template_state_get_event_info(const char *_event_name,
                                     int *_event_id,
                                     AppLayerEventType *_event_type);

int8_t rs_template_state_get_event_info_by_id(int _event_id,
                                              const char **_event_name,
                                              AppLayerEventType *_event_type);

AppLayerDecoderEvents *rs_template_state_get_events(void *tx);

void *rs_template_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_template_state_get_tx_count(void *state);

AppLayerGetTxIterTuple rs_template_state_get_tx_iterator(uint8_t _ipproto,
                                                         AppProto _alproto,
                                                         void *state,
                                                         uint64_t min_tx_id,
                                                         uint64_t _max_tx_id,
                                                         uint64_t *istate);

void *rs_template_state_new(void *_orig_state, AppProto _orig_proto);

int rs_template_state_progress_completion_status(uint8_t _direction);

void rs_template_state_tx_free(void *state, uint64_t tx_id);

int rs_template_tx_get_alstate_progress(void *tx, uint8_t _direction);

void *rs_tftp_get_tx(TFTPState *state, uint64_t tx_id);

uint64_t rs_tftp_get_tx_cnt(TFTPState *state);

AppLayerTxData *rs_tftp_get_tx_data(void *tx);

bool rs_tftp_log_json_request(TFTPTransaction *tx, JsonBuilder *jb);

int64_t rs_tftp_request(TFTPState *state, const uint8_t *input, uint32_t len);

void *rs_tftp_state_alloc(void);

void rs_tftp_state_free(void *state);

void rs_tftp_state_tx_free(TFTPState *state, uint64_t tx_id);

/**
 * Attempt to parse a X.509 from input, and return a pointer to the parsed object if successful.
 *
 * # Safety
 *
 * input must be a valid buffer of at least input_len bytes
 */
X509 *rs_x509_decode(const uint8_t *input,
                     uint32_t input_len,
                     uint32_t *err_code);

/**
 * Free a X.509 object allocated by Rust
 *
 * # Safety
 *
 * ptr must be a valid object obtained using `rs_x509_decode`
 */
void rs_x509_free(X509 *ptr);

char *rs_x509_get_issuer(const X509 *ptr);

char *rs_x509_get_serial(const X509 *ptr);

char *rs_x509_get_subject(const X509 *ptr);

/**
 * Extract validity from input X.509 object
 *
 * # Safety
 *
 * ptr must be a valid object obtained using `rs_x509_decode`
 */
int32_t rs_x509_get_validity(const X509 *ptr,
                             int64_t *not_before,
                             int64_t *not_after);

#endif /* __RUST_BINDINGS_GEN_H_ */
